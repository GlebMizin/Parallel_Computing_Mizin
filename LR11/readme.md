***

# ОТЧЕТ

## Лабораторная работа №11: Неблокирующие операции MPI (Isend/Irecv) и перекрытие вычислений/обмена

### Сведения о студенте

* **Дата:** 2025-12-28
* **Семестр:** 1
* **Группа:** ПИН-м-о-25-1 (1)
* **Дисциплина:** Параллельные вычисления
* **Студент:** Мизин Глеб Егорович

***

## 1. Цель работы

Изучить неблокирующие операции MPI и сравнить производительность двух вариантов обмена граничными данными (halo) при параллельном расчёте:

* **block**: блокирующий обмен (`Sendrecv`)
* **async**: неблокирующий обмен (`Irecv/Isend` + `Waitall`) с попыткой перекрыть обмен вычислениями

---

## 2. Постановка задачи (кратко)

Рассматривается 2D расчёт на сетке `(Nx+1)×(Ny+1)` с явной схемой по времени. Область распараллеливается по `x` (**1D-декомпозиция** на полосы). На каждом шаге времени нужно обменяться граничными строками с соседями.

---

## 3. Реализация

### Вариант block

На каждом шаге времени выполняется обмен граничными строками через `Sendrecv`, затем вычисляется следующий слой.

### Вариант async

На каждом шаге времени:

1. запускаются `Irecv` (приём ghost-строк), затем `Isend` (отправка своих границ)
2. пока обмен идёт — вычисляется “середина” полосы (ячейки, не зависящие от ghost)
3. `Waitall` и довычисление граничных строк

Использованные MPI операции: `Sendrecv`, `Isend`, `Irecv`, `Waitall`, `Barrier`, `Allreduce(MAX)`.

---

## 4. Параметры эксперимента

* `Nx = 50`, `Ny = 50`
* `M = 500` шагов по времени
  Время — `compute_time_max` (максимум по процессам). Корректность контролировалась через `checksum`.

---

## 5. Команды запуска

Пример:

```bash
mpiexec -n 4 python lr11_heat2d_async.py --mode block --Nx 50 --Ny 50 --M 500
mpiexec -n 4 python lr11_heat2d_async.py --mode async --Nx 50 --Ny 50 --M 500
```

---

## 6. Результаты

### 6.1. Время и checksum

**block**

|  p | T(p), сек |     checksum |
| -: | --------: | -----------: |
|  1 |  2.379513 | 1.166248e+03 |
|  2 |  1.281671 | 1.166248e+03 |
|  4 |  0.723707 | 1.166248e+03 |
|  8 |  0.624458 | 1.166248e+03 |

**async**

|  p | T(p), сек |     checksum |
| -: | --------: | -----------: |
|  1 |  2.488681 | 1.166248e+03 |
|  2 |  1.372576 | 1.166248e+03 |
|  4 |  0.744522 | 1.166248e+03 |
|  8 |  0.608355 | 1.166248e+03 |

Checksum одинаковый → результаты совпадают (численно одинаковый итог).

---

### 6.2. Ускорение и эффективность

Формулы:

* `S(p) = T(1) / T(p)`
* `E(p) = S(p) / p`

**block (T(1)=2.379513)**

|  p | Speedup S(p) | Efficiency E(p) |
| -: | -----------: | --------------: |
|  1 |        1.000 |           1.000 |
|  2 |        1.857 |           0.928 |
|  4 |        3.288 |           0.822 |
|  8 |        3.811 |           0.476 |

**async (T(1)=2.488681)**

|  p | Speedup S(p) | Efficiency E(p) |
| -: | -----------: | --------------: |
|  1 |        1.000 |           1.000 |
|  2 |        1.813 |           0.907 |
|  4 |        3.343 |           0.836 |
|  8 |        4.091 |           0.511 |

---

## 7. Вывод

Неблокирующий вариант (`async`) в данном эксперименте:

* на `p=1,2,4` оказался немного медленнее из-за накладных расходов на `Isend/Irecv/Waitall`;
* на `p=8` оказался немного быстрее (за счёт перекрытия вычислений и обмена).

Итого: неблокирующие операции могут давать выигрыш при достаточной доле коммуникаций и возможности реально перекрывать обмен полезными вычислениями.

---
